import tkinter as tk
from tkinter import filedialog, messagebox, simpledialog, ttk
import hashlib
import time
import os
import datetime
import threading
import secrets
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives import padding
from cryptography.hazmat.backends import default_backend

# Global variables
malicious_hashes = []
file_info = {
    "file_path": "",
    "size": "",
    "creation_time": "",
    "modification_time": "",
    "is_malicious": "",
    "hash": ""
}

# Function to calculate file hash
def calculate_hash(file_path):
    try:
        with open(file_path, 'rb') as f:
            bytes = f.read()
            readable_hash = hashlib.sha256(bytes).hexdigest()
            return readable_hash
    except Exception as e:
        print(f"Unable to calculate hash for file: {file_path}. Error: {str(e)}")
        return None

# Function to get file info
def get_file_info(file_path):
    size = os.path.getsize(file_path)
    creation_time = os.path.getctime(file_path)
    creation_time = datetime.datetime.fromtimestamp(creation_time)
    modification_time = os.path.getmtime(file_path)
    modification_time = datetime.datetime.fromtimestamp(modification_time)
    return size, creation_time, modification_time

# Function to check if a file is malicious
def check_file():
    file_path = filedialog.askopenfilename(title="Select File to Check")
    if file_path:
        perform_check(file_path)

def perform_check(file_path):
    # Rest of the check_file() function code remains the same
    # ...

    for i in range(5):
        progress_bar['value'] += 20
        progress_label.config(text=f"{progress_bar['value']}%")
        root.update_idletasks()
        time.sleep(0.5)
    
    file_hash = calculate_hash(file_path)
    dangerous_extensions = [".exe", ".bat", ".cmd", ".ps1", ".vbs", ".js"]
    
    if file_hash in malicious_hashes:
        result = f"File: {file_path} is malicious."
        is_malicious = "Yes"
    elif any(file_path.endswith(ext) for ext in dangerous_extensions):
        result = f"File: {file_path} has a potentially dangerous extension, but its hash doesn't match any known malicious hashes."
        is_malicious = "No, but has potentially dangerous extension"
    else:
        result = f"File: {file_path} is safe."
        is_malicious = "No"
    
    time.sleep(2)
    
    progress_bar['value'] = 100
    progress_label.config(text="100%")
    root.update_idletasks()
    
    size, creation_time, modification_time = get_file_info(file_path)
    
    result += f"\n\nFile size: {size} bytes"
    result += f"\nCreation time: {creation_time}"
    result += f"\nLast modification time: {modification_time}"
    result += f"\nHash: {file_hash}"
    
    file_info["file_path"] = file_path
    file_info["size"] = size
    file_info["creation_time"] = creation_time
    file_info["modification_time"] = modification_time
    file_info["is_malicious"] = is_malicious
    file_info["hash"] = file_hash
    
    messagebox.showinfo("Result", result)

# Function to encrypt a file
def encrypt_file():
    input_file = filedialog.askopenfilename(title="Select Input File")
    if not input_file:
        return
    
    output_file = filedialog.asksaveasfilename(title="Save Encrypted File", defaultextension=".aes")
    if not output_file:
        return
    
    generate_random_key = messagebox.askyesno("Generate Random Key", "Do you want to generate a random key?")
    if generate_random_key:
        key = secrets.token_bytes(32)
    else:
        key = simpledialog.askstring("Encryption Key", "Enter Encryption Key")
        if key is None:
            return
        key = key.encode()
    
    progress_bar["value"] = 0
    progress_label.config(text="0%")
    root.update_idletasks()
    
    try:
        backend = default_backend()
        cipher = Cipher(algorithms.AES(key), modes.ECB(), backend=backend)
        encryptor = cipher.encryptor()
        padder = padding.PKCS7(algorithms.AES.block_size).padder()
        
        with open(input_file, 'rb') as file:
            plaintext = file.read()
            padded_data = padder.update(plaintext) + padder.finalize()
            ciphertext = encryptor.update(padded_data) + encryptor.finalize()
        
        with open(output_file, 'wb') as file:
            file.write(ciphertext)
        
        key_file = output_file + ".key"
        save_key_to_file(key, key_file)
        
        progress_bar["value"] = 100
        progress_label.config(text="100%")
        root.update_idletasks()
        
        messagebox.showinfo("Success", "File encrypted successfully. Key saved to: " + key_file)
    except Exception as e:
        messagebox.showerror("Error", str(e))

# Function to decrypt a file
def decrypt_file():
    input_file = filedialog.askopenfilename(title="Select Input File")
    if not input_file:
        return
    
    output_file = filedialog.asksaveasfilename(title="Save Decrypted File", defaultextension=".txt")
    if not output_file:
        return
    
    key_file = filedialog.askopenfilename(title="Select Key File")
    if not key_file:
        return
    
    progress_bar["value"] = 0
    progress_label.config(text="0%")
    root.update_idletasks()
    
    try:
        backend = default_backend()
        cipher = Cipher(algorithms.AES(load_key_from_file(key_file)), modes.ECB(), backend=backend)
        decryptor = cipher.decryptor()
        unpadder = padding.PKCS7(algorithms.AES.block_size).unpadder()
        
        with open(input_file, 'rb') as file:
            ciphertext = file.read()
            decrypted_data = decryptor.update(ciphertext) + decryptor.finalize()
            unpadded_data = unpadder.update(decrypted_data) + unpadder.finalize()
        
        with open(output_file, 'wb') as file:
            file.write(unpadded_data)
        
        progress_bar["value"] = 100
        progress_label.config(text="100%")
        root.update_idletasks()
        
        messagebox.showinfo("Success", "File decrypted successfully.")
    except Exception as e:
        messagebox.showerror("Error", str(e))

# Function to save file info to a text file
def save_file_info():
    filename = filedialog.asksaveasfilename(defaultextension=".txt")
    if not filename:
        return
    
    with open(filename, "w") as f:
        f.write("File: " + str(file_info["file_path"]) + "\n")
        f.write("File size: " + str(file_info["size"]) + " bytes\n")
        f.write("Creation time: " + str(file_info["creation_time"]) + "\n")
        f.write("Last modification time: " + str(file_info["modification_time"]) + "\n")
        f.write("Is malicious: " + str(file_info["is_malicious"]) + "\n")
        f.write("Hash: " + str(file_info["hash"]) + "\n")

# Read malicious hashes from a text file
with open(r'C:\Users\kishan\Desktop\hashes.txt', 'r') as f:
    malicious_hashes = [line.strip() for line in f]

# Create the main window
root = tk.Tk()
root.title("File Malicious Behavior Checker and Encryptor/Decryptor")
root.geometry("600x400")

# Create a label
label = tk.Label(root, text="Please choose an action and upload a file.")
label.pack(pady=10)

# Create buttons for actions
check_button = tk.Button(root, text="Check for Malicious Behavior", command=check_file)
check_button.pack(pady=10)
encrypt_button = tk.Button(root, text="Encrypt File", command=encrypt_file)
encrypt_button.pack(pady=10)
decrypt_button = tk.Button(root, text="Decrypt File", command=decrypt_file)
decrypt_button.pack(pady=10)

# Create a progress bar and label
progress_bar = ttk.Progressbar(root, orient=tk.HORIZONTAL, length=200, mode='determinate')
progress_bar.pack()
progress_label = tk.Label(root, text="")
progress_label.pack()

# Start the main GUI loop
root.mainloop()